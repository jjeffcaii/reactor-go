// Code generated by MockGen. DO NOT EDIT.
// Source: subscriber.go

// Package subscribers is a generated GoMock package.
package subscribers

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	reactor "github.com/jjeffcaii/reactor-go"
	reflect "reflect"
)

// MockSubscription is a mock of Subscription interface
type MockSubscription struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriptionMockRecorder
}

// MockSubscriptionMockRecorder is the mock recorder for MockSubscription
type MockSubscriptionMockRecorder struct {
	mock *MockSubscription
}

// NewMockSubscription creates a new mock instance
func NewMockSubscription(ctrl *gomock.Controller) *MockSubscription {
	mock := &MockSubscription{ctrl: ctrl}
	mock.recorder = &MockSubscriptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSubscription) EXPECT() *MockSubscriptionMockRecorder {
	return m.recorder
}

// Request mocks base method
func (m *MockSubscription) Request(n int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Request", n)
}

// Request indicates an expected call of Request
func (mr *MockSubscriptionMockRecorder) Request(n interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Request", reflect.TypeOf((*MockSubscription)(nil).Request), n)
}

// Cancel mocks base method
func (m *MockSubscription) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel
func (mr *MockSubscriptionMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockSubscription)(nil).Cancel))
}

// MockSubscriber is a mock of Subscriber interface
type MockSubscriber struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriberMockRecorder
}

// MockSubscriberMockRecorder is the mock recorder for MockSubscriber
type MockSubscriberMockRecorder struct {
	mock *MockSubscriber
}

// NewMockSubscriber creates a new mock instance
func NewMockSubscriber(ctrl *gomock.Controller) *MockSubscriber {
	mock := &MockSubscriber{ctrl: ctrl}
	mock.recorder = &MockSubscriberMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSubscriber) EXPECT() *MockSubscriberMockRecorder {
	return m.recorder
}

// OnComplete mocks base method
func (m *MockSubscriber) OnComplete() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnComplete")
}

// OnComplete indicates an expected call of OnComplete
func (mr *MockSubscriberMockRecorder) OnComplete() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnComplete", reflect.TypeOf((*MockSubscriber)(nil).OnComplete))
}

// OnError mocks base method
func (m *MockSubscriber) OnError(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnError", arg0)
}

// OnError indicates an expected call of OnError
func (mr *MockSubscriberMockRecorder) OnError(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnError", reflect.TypeOf((*MockSubscriber)(nil).OnError), arg0)
}

// OnNext mocks base method
func (m *MockSubscriber) OnNext(arg0 reactor.Any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnNext", arg0)
}

// OnNext indicates an expected call of OnNext
func (mr *MockSubscriberMockRecorder) OnNext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnNext", reflect.TypeOf((*MockSubscriber)(nil).OnNext), arg0)
}

// OnSubscribe mocks base method
func (m *MockSubscriber) OnSubscribe(arg0 context.Context, arg1 reactor.Subscription) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnSubscribe", arg0, arg1)
}

// OnSubscribe indicates an expected call of OnSubscribe
func (mr *MockSubscriberMockRecorder) OnSubscribe(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnSubscribe", reflect.TypeOf((*MockSubscriber)(nil).OnSubscribe), arg0, arg1)
}
